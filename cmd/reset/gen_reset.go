package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/packages"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

var (
	resetPtrTemplate = template.Must(template.New("resetPtr").Parse(`
	if s.{{.Name}} != nil {
		*s.{{.Name}} = {{.Zero}}
	}`))

	resetPtrStringTemplate = template.Must(template.New("resetPtrString").Parse(`
	if s.{{.Name}} != nil {
		*s.{{.Name}} = ""
	}`))

	resetPtrBoolTemplate = template.Must(template.New("resetPtrBool").Parse(`
	if s.{{.Name}} != nil {
		*s.{{.Name}} = false
	}`))

	resetPtrResettableTemplate = template.Must(template.New("resetPtrResettable").Parse(`
	if s.{{.Name}} != nil {
		if resetter, ok := interface{}(s.{{.Name}}).(interface{ Reset() }); ok {
			resetter.Reset()
		}
	}`))

	resetInterfaceTemplate = template.Must(template.New("resetIface").Parse(`
	if resetter, ok := s.{{.Name}}.(interface{ Reset() }); ok {
		resetter.Reset()
	}`))
)

func apply(t *template.Template, data any) string {
	var b bytes.Buffer
	_ = t.Execute(&b, data)
	return b.String()
}

func genFieldReset(name string, t ast.Expr) string {
	switch tt := t.(type) {
	// values
	case *ast.Ident:
		switch tt.Name {
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"float32", "float64", "complex64", "complex128":
			return fmt.Sprintf("	s.%s = 0", name)
		case "string":
			return fmt.Sprintf(`	s.%s = ""`, name)
		case "bool":
			return fmt.Sprintf("	s.%s = false", name)
		default:
			return fmt.Sprintf("	// unsupported value field '%s'", name)
		}
	// pointers
	case *ast.StarExpr:
		if id, ok := tt.X.(*ast.Ident); ok {
			switch id.Name {
			case "int", "int8", "int16", "int32", "int64",
				"uint", "uint8", "uint16", "uint32", "uint64",
				"float32", "float64", "complex64", "complex128":
				return apply(resetPtrTemplate, map[string]any{
					"Name": name,
					"Zero": 0,
				})

			case "string":
				return apply(resetPtrStringTemplate, map[string]any{
					"Name": name,
				})

			case "bool":
				return apply(resetPtrBoolTemplate, map[string]any{
					"Name": name,
				})

			default:
				return apply(resetPtrResettableTemplate, map[string]any{
					"Name": name,
				})
			}
		}
		return fmt.Sprintf("	// unsupported pointer field '%s'", name)
	case *ast.ArrayType:
		if tt.Len != nil {
			return fmt.Sprintf("	// unsupported array field '%s'", name)
		}
		return fmt.Sprintf("	s.%s = s.%s[:0]", name, name)
	case *ast.MapType:
		return fmt.Sprintf("	clear(s.%s)", name)
	default:
		return apply(resetInterfaceTemplate, map[string]any{
			"Name": name,
		})
	}
}

func genReset(structName string, str *ast.StructType) string {
	var fieldLines []string

	for _, f := range str.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		name := f.Names[0].Name
		fieldLines = append(fieldLines, genFieldReset(name, f.Type))
	}

	return fmt.Sprintf(`
func (s *%s) Reset() {
	if s == nil {
		return
	}

%s
}`, structName, strings.Join(fieldLines, "\n"))
}

var structAnalyzer = &analysis.Analyzer{
	Name:       "resetcheck",
	Doc:        "Finds structs with // generate:reset comments",
	Run:        run,
	ResultType: reflect.TypeOf([]string{}),
}

func run(pass *analysis.Pass) (interface{}, error) {
	var res []string
	for _, f := range pass.Files {
		ast.Inspect(f, func(n ast.Node) bool {
			gd, ok := n.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				return true
			}

			for _, spec := range gd.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if gd.Doc != nil {
					for _, c := range gd.Doc.List {
						if strings.Contains(c.Text, "generate:reset") {
							res = append(res, genReset(ts.Name.Name, st))
						}
					}
				}
			}

			return true
		})
	}
	return res, nil
}

func writeResets(pkg string, path string, methods []string) error {
	if len(methods) == 0 {
		return nil
	}

	f, err := os.Create(filepath.Join(path, "reset.gen.go"))
	if err != nil {
		return fmt.Errorf("unable to create reset.gen.go: %w", err)
	}
	defer f.Close()

	_, err = fmt.Fprintf(f, `// Code generated by reset-gen. DO NOT EDIT.

package %s

%s

`, pkg, strings.Join(methods, "\n\n"))

	if err != nil {
		return fmt.Errorf("unable to write reset.gen.go: %w", err)
	}

	return nil
}

func main() {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax,
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		log.Fatal("unable to load packages", err)
	}

	if packages.PrintErrors(pkgs) > 0 {
		log.Fatal("package load errors")
	}

	for _, pkg := range pkgs {
		res, err := structAnalyzer.Run(&analysis.Pass{
			Analyzer: structAnalyzer,
			Files:    pkg.Syntax,
		})

		if err != nil {
			log.Fatal("unable to run analyzer", err)
		}

		dir := filepath.Dir(pkg.GoFiles[0])
		err = writeResets(pkg.Name, dir, res.([]string))
		if err != nil {
			log.Fatal(err)
		}
	}
}
